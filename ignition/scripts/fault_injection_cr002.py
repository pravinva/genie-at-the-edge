"""
CR_002 Fault Injection Script - Bearing Degradation Simulation

This script simulates a realistic bearing failure in Crusher 2 (CR_002) over a 48-hour period.
Used to demonstrate predictive maintenance capabilities and Genie's anomaly detection.

FAULT TIMELINE:
  Hours 0-24:  Normal operation (vibration 18-22 mm/s)
  Hours 24-36: Early degradation (vibration rises to 28-32 mm/s)
  Hours 36-42: Warning state (vibration 35-45 mm/s, throughput drops)
  Hours 42-48: Critical failure (vibration 55-70 mm/s, temperature spikes)

DEPLOYMENT OPTIONS:

Option 1: Manual trigger (for demos)
  - Designer > Script Console
  - Paste this file
  - Execute: start_cr002_fault_sequence()

Option 2: Scheduled event
  - Gateway > Config > Gateway Event Scripts > Scheduled Scripts
  - Schedule to run at specific demo time

Option 3: Gateway Timer Script
  - Create separate timer script that checks "fault enabled" tag
  - If enabled, execute fault progression logic

TESTING:
  - Accelerated mode: 48 hours -> 48 minutes (1 hour = 1 minute)
  - Real-time mode: Actual 48-hour progression
  - Reset function: Restore CR_002 to normal state

Author: Generated by Claude Code
Date: 2026-02-14
Version: 1.0
"""

import system.tag
import system.util
import random
from java.lang import Math

# ============================================
# CONFIGURATION
# ============================================

# Target equipment
EQUIPMENT_ID = "CR_002"
TAG_BASE_PATH = "[default]Mining/Equipment/{}".format(EQUIPMENT_ID)

# Fault progression (in hours for real-time mode)
FAULT_DURATION_HOURS = 48.0
PHASE_1_END = 24.0  # Normal -> Early degradation
PHASE_2_END = 36.0  # Early -> Warning
PHASE_3_END = 42.0  # Warning -> Critical
PHASE_4_END = 48.0  # Critical -> Failure

# Normal operation parameters
NORMAL_THROUGHPUT = 2400.0
NORMAL_VIBRATION = 20.0
NORMAL_MOTOR_TEMP = 75.0
NORMAL_MOTOR_CURRENT = 200.0

# Logging
logger = system.util.getLogger("CR002_FaultInjection")

# ============================================
# FAULT STATE TAG
# ============================================

# This script uses a custom memory tag to track fault state
# Tag path: [default]Mining/Equipment/CR_002/Fault_State
# Members:
#   - Enabled (Boolean): Is fault active?
#   - Start_Time (DateTime): When fault started
#   - Elapsed_Hours (Float): Hours elapsed since fault start
#   - Current_Phase (String): normal, early, warning, critical, failed

def initialize_fault_state_tags():
    """
    Create fault state tags if they don't exist
    These tags track the progression of the bearing failure
    """
    fault_tags = [
        TAG_BASE_PATH + "/Fault_Enabled",
        TAG_BASE_PATH + "/Fault_Start_Time",
        TAG_BASE_PATH + "/Fault_Elapsed_Hours",
        TAG_BASE_PATH + "/Fault_Phase"
    ]

    try:
        # Try to read - if fails, tags need to be created manually
        values = system.tag.readBlocking(fault_tags)

        # If we get here, tags exist
        logger.info("Fault state tags exist")

    except:
        logger.warn("Fault state tags not found - create manually or use Gateway tags")
        logger.warn("Required tags: Fault_Enabled, Fault_Start_Time, Fault_Elapsed_Hours, Fault_Phase")


# ============================================
# FAULT PROGRESSION CALCULATIONS
# ============================================

def calculate_degraded_vibration(elapsed_hours, bearing_condition):
    """
    Calculate vibration based on bearing wear progression

    Physics:
    - Normal: 18-22 mm/s (±10%)
    - Early wear: 25-35 mm/s (bearing clearance increases)
    - Advanced wear: 40-55 mm/s (significant imbalance)
    - Critical: 60-80 mm/s (imminent failure)

    Args:
        elapsed_hours (float): Hours since fault started
        bearing_condition (float): Bearing health (0-1, 1=perfect)

    Returns:
        float: Vibration in mm/s
    """
    # Base vibration increases as bearing degrades
    base_vibration = NORMAL_VIBRATION / max(0.25, bearing_condition)

    # Add periodic spikes (simulates bearing cage hitting worn race)
    spike_frequency = 5.0 / bearing_condition  # More frequent as it wears
    spike_amplitude = 15.0 * (1.0 - bearing_condition)
    spike = spike_amplitude * abs(Math.sin(elapsed_hours * spike_frequency))

    # Random component increases with wear
    noise_amplitude = 2.0 + (1.0 - bearing_condition) * 10.0
    noise = random.uniform(-noise_amplitude, noise_amplitude)

    vibration = base_vibration + spike + noise

    return max(5.0, vibration)


def calculate_degraded_throughput(elapsed_hours, bearing_condition):
    """
    Calculate throughput reduction due to vibration/reliability concerns

    As vibration increases, operators reduce throughput to avoid catastrophic failure

    Args:
        elapsed_hours (float): Hours since fault started
        bearing_condition (float): Bearing health (0-1)

    Returns:
        float: Throughput in tonnes/hour
    """
    # Throughput reduction based on bearing condition
    # Operators slow down equipment when vibration is high
    if bearing_condition > 0.7:
        # Normal operation
        throughput = NORMAL_THROUGHPUT + random.uniform(-100, 100)
    elif bearing_condition > 0.5:
        # Slight reduction
        throughput = NORMAL_THROUGHPUT * 0.9 + random.uniform(-80, 80)
    elif bearing_condition > 0.3:
        # Significant reduction
        throughput = NORMAL_THROUGHPUT * 0.75 + random.uniform(-60, 60)
    else:
        # Critical - major reduction or shutdown imminent
        throughput = NORMAL_THROUGHPUT * 0.5 + random.uniform(-100, 100)
        # Occasional shutdown attempts
        if random.random() < 0.1:
            throughput = 0.0

    return max(0.0, throughput)


def calculate_degraded_motor_temp(vibration, throughput):
    """
    Calculate motor temperature increase due to imbalance

    High vibration causes additional bearing friction -> heat

    Args:
        vibration (float): Current vibration in mm/s
        throughput (float): Current throughput in tonnes/hour

    Returns:
        float: Motor temperature in °C
    """
    # Base temperature from normal operation
    base_temp = NORMAL_MOTOR_TEMP

    # Vibration causes additional friction heating
    vibration_heating = (vibration - NORMAL_VIBRATION) * 0.5

    # Throughput loading
    throughput_heating = (throughput / NORMAL_THROUGHPUT) * 10.0

    # Random fluctuation
    noise = random.uniform(-2.0, 2.0)

    temp = base_temp + vibration_heating + throughput_heating + noise

    return max(50.0, min(150.0, temp))


def calculate_bearing_condition(elapsed_hours):
    """
    Calculate bearing condition based on fault progression

    Args:
        elapsed_hours (float): Hours since fault started

    Returns:
        float: Bearing condition (0-1, 1=perfect, 0=failed)
    """
    if elapsed_hours < PHASE_1_END:
        # Phase 1: Normal operation (condition slowly degrades)
        degradation = elapsed_hours / PHASE_1_END * 0.15  # Lose 15% health
        condition = 1.0 - degradation

    elif elapsed_hours < PHASE_2_END:
        # Phase 2: Early degradation (accelerated wear)
        phase_progress = (elapsed_hours - PHASE_1_END) / (PHASE_2_END - PHASE_1_END)
        condition = 0.85 - (phase_progress * 0.35)  # 85% -> 50%

    elif elapsed_hours < PHASE_3_END:
        # Phase 3: Warning state (rapid deterioration)
        phase_progress = (elapsed_hours - PHASE_2_END) / (PHASE_3_END - PHASE_2_END)
        condition = 0.50 - (phase_progress * 0.30)  # 50% -> 20%

    else:
        # Phase 4: Critical failure (imminent failure)
        phase_progress = (elapsed_hours - PHASE_3_END) / (PHASE_4_END - PHASE_3_END)
        condition = 0.20 - (phase_progress * 0.20)  # 20% -> 0%

    return max(0.0, condition)


def get_fault_phase(elapsed_hours):
    """Get current fault phase as string"""
    if elapsed_hours < PHASE_1_END:
        return "normal_degrading"
    elif elapsed_hours < PHASE_2_END:
        return "early_degradation"
    elif elapsed_hours < PHASE_3_END:
        return "warning"
    elif elapsed_hours < PHASE_4_END:
        return "critical"
    else:
        return "failed"


# ============================================
# FAULT EXECUTION
# ============================================

def execute_fault_progression(elapsed_hours_override=None, accelerated=False):
    """
    Execute one step of fault progression

    This function should be called periodically (e.g., every 1 second) by a timer script

    Args:
        elapsed_hours_override (float): Override elapsed time (for testing)
        accelerated (bool): If True, 1 minute = 1 hour (48 min demo)

    Returns:
        dict: Current fault state
    """
    try:
        # Read fault state
        fault_tags = [
            TAG_BASE_PATH + "/Fault_Enabled",
            TAG_BASE_PATH + "/Fault_Start_Time",
            TAG_BASE_PATH + "/Fault_Elapsed_Hours"
        ]

        values = system.tag.readBlocking(fault_tags)
        fault_enabled = values[0].value
        fault_start_time = values[1].value
        elapsed_hours = values[2].value

        # If fault not enabled, do nothing
        if not fault_enabled:
            return {"enabled": False, "message": "Fault not enabled"}

        # Calculate elapsed time
        if elapsed_hours_override is not None:
            elapsed_hours = elapsed_hours_override
        else:
            # Calculate elapsed time since start
            import time
            current_time = time.time()
            start_timestamp = fault_start_time / 1000.0 if fault_start_time else current_time

            elapsed_seconds = current_time - start_timestamp

            if accelerated:
                # Accelerated: 1 minute = 1 hour
                elapsed_hours = elapsed_seconds / 60.0
            else:
                # Real-time: normal hours
                elapsed_hours = elapsed_seconds / 3600.0

        # Calculate bearing condition
        bearing_condition = calculate_bearing_condition(elapsed_hours)

        # Calculate degraded parameters
        vibration = calculate_degraded_vibration(elapsed_hours, bearing_condition)
        throughput = calculate_degraded_throughput(elapsed_hours, bearing_condition)
        motor_temp = calculate_degraded_motor_temp(vibration, throughput)

        # Motor current scales with throughput
        motor_current = NORMAL_MOTOR_CURRENT * (throughput / NORMAL_THROUGHPUT)
        motor_current = motor_current + random.uniform(-10, 10)

        # Other parameters
        belt_speed = 2.0 + random.uniform(-0.05, 0.05)
        chute_level = 60.0 + random.uniform(-10, 10)
        feed_rate = throughput * 1.05

        # Status
        phase = get_fault_phase(elapsed_hours)
        if phase == "failed":
            status = "FAULT"
        elif phase in ["warning", "critical"]:
            status = "DEGRADED"
        else:
            status = "RUNNING"

        # Write updates to equipment tags
        write_paths = [
            TAG_BASE_PATH + "/Vibration_MM_S",
            TAG_BASE_PATH + "/Throughput_TPH",
            TAG_BASE_PATH + "/Motor_Temp_C",
            TAG_BASE_PATH + "/Motor_Current_A",
            TAG_BASE_PATH + "/Belt_Speed_M_S",
            TAG_BASE_PATH + "/Chute_Level_Pct",
            TAG_BASE_PATH + "/Feed_Rate_TPH",
            TAG_BASE_PATH + "/Status",
            TAG_BASE_PATH + "/Fault_Elapsed_Hours",
            TAG_BASE_PATH + "/Fault_Phase"
        ]

        write_values = [
            vibration,
            throughput,
            motor_temp,
            motor_current,
            belt_speed,
            chute_level,
            feed_rate,
            status,
            elapsed_hours,
            phase
        ]

        system.tag.writeBlocking(write_paths, write_values)

        # Log progress periodically
        if int(elapsed_hours) != int(elapsed_hours - (1.0/3600.0)):  # Log every hour
            logger.info("CR_002 fault progression: {:.1f} hours, phase: {}, vibration: {:.1f} mm/s".format(
                elapsed_hours, phase, vibration))

        return {
            "enabled": True,
            "elapsed_hours": elapsed_hours,
            "phase": phase,
            "bearing_condition": bearing_condition,
            "vibration": vibration,
            "throughput": throughput,
            "motor_temp": motor_temp,
            "status": status
        }

    except Exception as e:
        logger.error("Error executing fault progression: {}".format(str(e)))
        import traceback
        logger.error(traceback.format_exc())
        return {"enabled": False, "error": str(e)}


# ============================================
# USER INTERFACE FUNCTIONS
# ============================================

def start_cr002_fault_sequence(accelerated=False):
    """
    Start the CR_002 bearing failure sequence

    Args:
        accelerated (bool): If True, run in accelerated mode (48 min instead of 48 hr)

    Usage:
        # Normal speed (48 hours)
        start_cr002_fault_sequence()

        # Accelerated (48 minutes for demo)
        start_cr002_fault_sequence(accelerated=True)
    """
    try:
        import time

        # Set fault enabled
        fault_tags = [
            TAG_BASE_PATH + "/Fault_Enabled",
            TAG_BASE_PATH + "/Fault_Start_Time",
            TAG_BASE_PATH + "/Fault_Elapsed_Hours",
            TAG_BASE_PATH + "/Fault_Phase"
        ]

        fault_values = [
            True,
            long(time.time() * 1000),  # Current time in milliseconds
            0.0,
            "normal_degrading"
        ]

        system.tag.writeBlocking(fault_tags, fault_values)

        mode = "ACCELERATED (48 minutes)" if accelerated else "REAL-TIME (48 hours)"
        logger.info("CR_002 fault sequence started - Mode: {}".format(mode))

        return "Fault sequence started for CR_002 - Mode: {}".format(mode)

    except Exception as e:
        error_msg = "Error starting fault sequence: {}".format(str(e))
        logger.error(error_msg)
        return error_msg


def stop_cr002_fault_sequence():
    """
    Stop the fault sequence and restore normal operation
    """
    try:
        # Disable fault
        fault_tags = [
            TAG_BASE_PATH + "/Fault_Enabled",
            TAG_BASE_PATH + "/Fault_Elapsed_Hours",
            TAG_BASE_PATH + "/Fault_Phase"
        ]

        fault_values = [
            False,
            0.0,
            "normal"
        ]

        system.tag.writeBlocking(fault_tags, fault_values)

        # Restore normal parameters
        normal_tags = [
            TAG_BASE_PATH + "/Vibration_MM_S",
            TAG_BASE_PATH + "/Throughput_TPH",
            TAG_BASE_PATH + "/Motor_Temp_C",
            TAG_BASE_PATH + "/Motor_Current_A",
            TAG_BASE_PATH + "/Status"
        ]

        normal_values = [
            NORMAL_VIBRATION,
            NORMAL_THROUGHPUT,
            NORMAL_MOTOR_TEMP,
            NORMAL_MOTOR_CURRENT,
            "RUNNING"
        ]

        system.tag.writeBlocking(normal_tags, normal_values)

        logger.info("CR_002 fault sequence stopped - restored to normal operation")

        return "Fault sequence stopped - CR_002 restored to normal"

    except Exception as e:
        error_msg = "Error stopping fault sequence: {}".format(str(e))
        logger.error(error_msg)
        return error_msg


def get_fault_status():
    """
    Get current fault status for CR_002

    Returns:
        dict: Current fault state
    """
    try:
        fault_tags = [
            TAG_BASE_PATH + "/Fault_Enabled",
            TAG_BASE_PATH + "/Fault_Elapsed_Hours",
            TAG_BASE_PATH + "/Fault_Phase",
            TAG_BASE_PATH + "/Vibration_MM_S",
            TAG_BASE_PATH + "/Throughput_TPH",
            TAG_BASE_PATH + "/Status"
        ]

        values = system.tag.readBlocking(fault_tags)

        return {
            "enabled": values[0].value,
            "elapsed_hours": values[1].value,
            "phase": values[2].value,
            "vibration": values[3].value,
            "throughput": values[4].value,
            "status": values[5].value
        }

    except Exception as e:
        logger.error("Error getting fault status: {}".format(str(e)))
        return {"error": str(e)}


def simulate_fault_at_hour(hour, accelerated=False):
    """
    Jump to a specific hour in the fault progression (for testing/demo)

    Args:
        hour (float): Target hour (0-48)
        accelerated (bool): Use accelerated mode

    Usage:
        # Jump to hour 30 (warning phase)
        simulate_fault_at_hour(30)

        # Jump to hour 45 (critical phase)
        simulate_fault_at_hour(45)
    """
    try:
        # Enable fault if not already enabled
        start_cr002_fault_sequence(accelerated=accelerated)

        # Execute progression at target hour
        state = execute_fault_progression(elapsed_hours_override=hour, accelerated=accelerated)

        logger.info("CR_002 jumped to hour {}: phase={}, vibration={:.1f} mm/s".format(
            hour, state.get('phase', 'unknown'), state.get('vibration', 0)))

        return state

    except Exception as e:
        error_msg = "Error simulating fault at hour {}: {}".format(hour, str(e))
        logger.error(error_msg)
        return {"error": error_msg}


# ============================================
# TESTING / DEMO HELPERS
# ============================================

def run_fault_demo_sequence():
    """
    Run a quick demo showing all fault phases

    Executes:
    - Hour 0: Normal
    - Hour 25: Early degradation
    - Hour 38: Warning
    - Hour 44: Critical
    - Hour 48: Failed
    - Restore: Normal
    """
    logger.info("Starting CR_002 fault demo sequence...")

    phases = [
        (0, "Normal operation"),
        (25, "Early degradation"),
        (38, "Warning state"),
        (44, "Critical state"),
        (48, "Failed state")
    ]

    for hour, description in phases:
        logger.info("Demo: {} (hour {})".format(description, hour))
        state = simulate_fault_at_hour(hour)
        logger.info("  Vibration: {:.1f} mm/s, Throughput: {:.0f} t/hr, Temp: {:.1f} C".format(
            state.get('vibration', 0),
            state.get('throughput', 0),
            state.get('motor_temp', 0)
        ))

        # Wait 5 seconds between phases (for visualization)
        system.util.invokeLater(lambda: None, 5000)

    # Restore normal
    logger.info("Demo: Restoring normal operation")
    stop_cr002_fault_sequence()

    logger.info("CR_002 fault demo sequence complete")


# ============================================
# MAIN (for script console testing)
# ============================================

if __name__ == '__main__' or True:
    # When pasted into Script Console, you can call:
    #
    # Start fault:
    #   start_cr002_fault_sequence(accelerated=True)
    #
    # Check status:
    #   get_fault_status()
    #
    # Jump to specific hour:
    #   simulate_fault_at_hour(30)
    #
    # Stop fault:
    #   stop_cr002_fault_sequence()
    #
    # Run demo:
    #   run_fault_demo_sequence()

    logger.info("CR_002 Fault Injection script loaded - use functions above to control fault")
